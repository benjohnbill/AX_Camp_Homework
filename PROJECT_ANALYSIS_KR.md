# AX_Camp_Homework 프로젝트 상세 분석

## 1) 한 줄 요약
이 프로젝트는 **개인 성찰 로그를 기록/검색/시각화하고, LLM으로 자기 점검 루프를 만드는 Streamlit 기반 앱**입니다. UI(`app.py`)와 정책/AI 로직(`narrative_logic.py`), 저장소 계층(`db_manager*.py`)이 분리되어 있으며, SQLite 기본 + Postgres 확장을 동시에 고려한 구조입니다.

---

## 2) 전체 아키텍처

### 2-1. 실행 진입점과 화면 구성
- 진입점은 `app.py`이며, 세션 초기화 후 **5개 모드(Stream/Chronos/Universe/Control/Desk)** 를 라우팅합니다.
- 앱 시작 시 최초 1회에 제네시스 데이터 주입 및 진단 로직을 수행하고, 스트릭(streak)도 갱신합니다.
- Red Mode가 활성화되면 일반 기능 대신 해명(사과) 폼으로 강제 전환되는 게 핵심 UX 제어입니다.

### 2-2. 비즈니스/AI 로직
- `narrative_logic.py`가 핵심 서비스 계층입니다.
- `EvidenceGateway`는 외부 I/O(임베딩 API, DB 점검, 입력 정제, 회복탄력성)를 담당하고,
  `PolicyEngine`은 규칙 판단(침묵 경고, 위반 판정) 중심으로 분리되어 있습니다.
- 검색은 **벡터 검색 + 키워드 검색 하이브리드**이며, FAISS/Annoy 인덱스가 없을 때는 numpy/sklearn 기반 브루트포스 fallback이 있습니다.

### 2-3. 데이터 계층
- 기본 저장소는 SQLite(`db_manager.py`, `db_manager_sqlite.py`)입니다.
- 라우터(`db_router.py`)를 통해 `DATASTORE=postgres`일 때 Postgres 전용 구현(`db_manager_postgres.py`)을 사용합니다.
- Postgres 경로는 `pgvector` 기반 유사도 검색과 GIN FTS 인덱스를 고려한 설계입니다.

---

## 3) 주요 기능 관점 분석

### 3-1. 기록/대화 루프 (Stream)
- 사용자가 입력한 텍스트를 로그/채팅 히스토리에 저장하고,
- 첫 입력은 "Meteor Effect"로 무응답 저장,
- 이후 입력부터 관련 로그를 찾아 LLM 응답을 생성합니다.
- 즉, "저장 → 유사 기록 탐색 → 반영 응답" 루프가 자연스럽게 설계되어 있습니다.

### 3-2. 자기교정 루프 (Red Protocol)
- 위반 시 `debt_count` 기반으로 RED 프로토콜을 트리거합니다.
- 해명은 텍스트 길이 + 원인/감정/실행계획 토큰 기반으로 품질 점수를 매기고,
  점수에 따라 보상 포인트를 차등 부여합니다.
- 단순 페널티가 아니라 "회복 포인트" 개념이 있어 행동 교정 UX가 명확합니다.

### 3-3. 생산성/정리 루프 (Chronos & Kanban)
- Chronos는 집중 시간 타이머 + 헌법 도킹(귀속)을 지원합니다.
- Control 모드는 draft/orbit/landed 칸반 흐름을 통해 생각을 실행 단위로 전환합니다.
- Desk 모드는 프래그먼트를 읽고 장문 에세이로 재구성하는 공간입니다.

### 3-4. 탐색/분석 루프 (Universe)
- Universe 탭은 로그 관측 + 트리맵(Finviz) 시각화를 제공합니다.
- 정량 신호(health_score, size 등)를 시각층으로 올려 자기 인식 강화에 초점이 있습니다.

---

## 4) 코드 품질/구조 장점

1. **기능 분해가 비교적 명확함**
   - UI/로직/DB 계층 분리가 되어 있어 학습/확장에 유리합니다.
2. **회복 탄력성 장치 존재**
   - API 실패 시 Circuit Breaker(degraded mode), 검색 fallback, FTS 실패 graceful skip 등 운영 친화 패턴이 들어가 있습니다.
3. **멀티 백엔드 전환 고려**
   - SQLite와 Postgres를 라우팅으로 분기해 배포 시 유연성이 있습니다.
4. **테스트가 핵심 경로를 커버**
   - 리팩터링 로직(정제/침묵 감지/서킷브레이커)과 하이브리드 랭킹 테스트가 존재합니다.

---

## 5) 리스크/개선 포인트 (중요)

1. **`narrative_logic.py` 비대화**
   - 단일 파일에 정책, 검색, 통계, LLM 프롬프트, UI 보조 로직이 혼재되어 유지보수 난이도가 높습니다.
   - `services/`(search, policy, analytics, llm)로 모듈 분리 시 개선폭이 큽니다.

2. **SQLite FTS 구성의 일관성 점검 필요**
   - `db_manager.py`와 `db_manager_sqlite.py`의 FTS 구성 컬럼/방식이 달라 운영 시 혼선을 줄 수 있습니다.
   - 단일 스키마 기준으로 정렬하는 것이 안전합니다.

3. **시간대(UTC) 처리 일관성 보강 필요**
   - 코드상 UTC 의도는 있으나 naive datetime과 혼용되는 부분이 보여 분석/알림 경계값에서 오차가 날 수 있습니다.

4. **DB 추상화 경계가 완전하지 않음**
   - 일부 로직은 여전히 SQLite 전제(예: 직접 sqlite3/FTS 문맥)라 Postgres 전환 시 기능 편차가 발생할 수 있습니다.

5. **AI 의존 경로의 관찰성 부족**
   - 실패 카운트는 있으나 메트릭/로그 집계(예: 실패율, 응답지연) 체계가 약해 운영에서 원인 추적이 어렵습니다.

---

## 6) 우선순위 기반 개선 로드맵

### 단기 (1~2주)
- `narrative_logic.py`를 최소 3개 모듈(`policy`, `search`, `analytics`)로 분리
- FTS 스키마/인덱스 전략을 SQLite/Postgres 각각 문서화 + 통일 인터페이스 제공
- datetime 저장/조회 규칙(UTC 고정, ISO8601) 명문화

### 중기 (3~4주)
- DB 접근을 `repository` 계층으로 통합해 SQLite/Postgres 기능 parity 확보
- LLM 호출부에 표준화된 재시도 정책/타임아웃/에러 코드 분류 추가
- 검색 품질 측정용 오프라인 평가 스크립트 추가(top-k recall, MRR 등)

### 장기
- 개인 데이터 민감도 고려한 암호화/보존주기/삭제 정책 정립
- 사용자 행동 루프(스트릭/회복포인트)의 실제 효과를 측정하는 실험 프레임 구축

---

## 7) 테스트/검증 상태
- 현재 `pytest -q` 기준 **10개 테스트 전부 통과** 상태입니다.
- 즉시 깨지는 기본 회귀 이슈는 낮아 보이나,
  실제 LLM/외부 API/DB 운영 경로의 통합 테스트는 별도로 강화할 가치가 큽니다.

---

## 8) 결론
이 프로젝트는 단순 일기 앱이 아니라 **"기록 → 반성 → 교정"을 제품 구조로 구현한 실험적 자기성찰 시스템**입니다.
핵심 아이디어와 기능 연결성은 매우 좋고, 이미 실사용을 염두에 둔 회복탄력성 장치도 들어가 있습니다.
다만 다음 단계로 가려면, **로직 모듈화 + 저장소 추상화 정교화 + 시간/검색 일관성 정리**가 가장 큰 레버리지 포인트입니다.
